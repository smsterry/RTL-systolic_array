# RTL design of the Output-stationary Systolic Array
---
## Overview
### I/O 
* **Input**: matrix A (size: M x K), B (size: K x N)
* **Output**: matrix C (size: M x N) where C = A x B

### Architecture
This systolic array consists of SRAMs, FIFOs, and a PE array.
* **Operand 1 SRAM**: It stores the first operand matrix (i.e. matrix A)
* **Operand 2 SRAM**: It stores the second operand matrix (i.e. matrix B)
* **Output SRAM**: It stores the output matrix (i.e. matrix C)
* **PE array**: It computes C = A x B with the output-stationary scheme
* **FIFOs**: They adjust the timing when each operand goes into the PE array
* **Controller**: It generates control signals according to the current state and cycle counts.

![image](https://github.com/user-attachments/assets/cc86cafb-800d-4bb9-aeb6-49fde20f12e0)

### Operation
There are 3 states in this systolic array.
* **IDLE**: Literally, it is the state where the array is idle. Do nothing.
* **COMPUTE**: In this state, the PE array computes a tile of the output matrix.
* **FLUSH**: In this state, the PE array flushes accumulated partial sums (i.e. a tile of the output matrix).

State transition occurs according to conditions shown in Fig 2.

![image](https://github.com/user-attachments/assets/b5bf497a-58ba-4440-9edd-3d03c89d3639)

---
## Implementation details
### SRAMs
There are 3 SRAMs in this systolic array (the operand 1/2 SRAM and output SRAM).
* In **operand 1 SRAM**, entries **must** be stored with the **column-major** order.
* In **operand 2 SRAM**, entries **must** be stored with the **row-major** order.
* In **output SRAM**, entries are stored with the **row-major** order.

Note that the bitwidth of a row in each SRAM **must** be aligned with the size of the PE array.
For instance, if the bitwidth of the input operand is 8 and the number of rows in the PE array is 4, 
each row in the operand 1 SRAM should consist of 32 bits, which is 8 bits x 4.

### FIFOs
There are FIFOs between operand1/2 SRAM and the first row/column of the PE array to adjust the timing
when each operand flows into the PE array. These FIFOs are controlled by the signals generated by the controller, 
based on the compute count. For the operand 1 FIFOS, the maximum depth is (# rows in PE array) - 1, 
and for the operand 2 FIFOs, the maximum depth is (# columns in PE array) - 1.

![image](https://github.com/user-attachments/assets/2df809ec-0b6b-4dc0-b22d-a403ed51c121)

### PE array
PE array consists of 2-D array of PEs. 
* In **COMPUTE** state, each PE computes 1 MAC and updates its own operand buffers or not according to the valid signal.
* IN **FLUSH** state, each PE transfers its accumulated partial sum to the PE on the next row (and same column).

![image](https://github.com/user-attachments/assets/d5cba8e4-a1ba-45e4-b250-2e3900259af5)

### Controller
Controller consists of registers that store state control signal, address control signal, matrix configuration, 
and combinational logic. Every cycle, it updates its control signals and internal states according to current signals.

---
## How to use
1. Compile "print_matrix.c". It will generate 3 .hex files (2 for the operand matrix, 1 for the answer), and 3 .txt files.
2. Move .hex files for the operand matrices (e.g. matrix1.hex, matrix2.hex) to the appropriate location (You may rename files).
3. Change ROMDATA ports of the operand1/2 SRAMs into the file location where operand matrices stored.
   Also, change WRITEDATA ports of the output SRAM into the location where you want to generate the answer file
   (the answer file is the final entries stored in the output SRAM).
4. Compile all Verilog files and simulate "TB_SYSTOLIC_ARRAY" module.
5. You can change configuration of input matrices (i.e. M, N, K values) and architecture (e.g. PE array size).

---
## Configuration
* **OPND_BWIDTH**: The bitwidth of the input operands (default = 8).
* **OPND_BWIDTH_LOG2**: It **must** be log_2(OPND_BWIDTH) (default = 3).
* **ACC_BWIDTH**: The bitwidth of the accumulated partial sums (default = 32).
* **ACC_BWIDTH_LOG2**: It **must** be log_2(ACC_BWIDTH) (default = 5).
* **OPND1_SRAM_AWIDTH**: The bitwidth of row-address used in the operand 1 SRAM.
  Make sure it is large enough to store the entire operand 1 matrix entries (default = 10).
* **OPND1_SRAM_BWIDTH**: The bitwidth of rows in the operand 1 SRAM.
  It **must** be (# of rows in the PE array) x (OPND_BWIDTH) (default = 32 x 8).
* **OPND2_SRAM_AWIDTH**: The bitwidth of row-address used in the operand 2 SRAM.
  Make sure it is large enough to store the entire operand 2 matrix entries (default = 10).
* **OPND2_SRAM_BWIDTH**: The bitwidth of rows in the operand 2 SRAM.
  It **must** be (# of columns in the PE array) x (OPND_BWIDTH) (default = 32 x 8).
* **OUT_SRAM_AWIDTH**: The bitwidth of row-address used in the output SRAM.
  Make sure it is large enough to store the entire output matrix entries (default = 10).
* **OUT_SRAM_BWIDTH**: The bitwidth of rows in the output SRAM.
  It **must** be (# of columns in the PE array) x (ACC_BWIDTH) (default = 32 x 32).
* **PE_ARRAY_NUM_ROWS**: The number of rows in the PE array (default = 32).
* **PE_ARRAY_NUM_ROWS_LOG2**: It **must** be log_2(PE_ARRAY_NUM_ROWS) (default = 5).
* **PE_ARRAY_NUM_COLS**: The number of columns in the PE array (default = 32).
* **PE_ARRAY_NUM_COLS_LOG2**: It **must** be log_2(PE_ARRAY_NUM_COLS) (default = 5).
* **MAX_M_SIZE_LOG2**: Log 2 value of the maximum size of M (# rows of the 1st operand matrix) (default = 9).
* **MAX_K_SIZE_LOG2**: Log 2 value of the maximum size of K (# rows of the 2nd operand matrix) (default = 9).
* **MAX_N_SIZE_LOG2**: Log 2 value of the maximum size of N (# columns of the 2nd operand matrix) (default = 9).

If the size of each input matrix is large, it is recommended to adjust AWIDTH values.
Also, please adjust timings of $finish() at "TB_SYSTOLIC_ARRAY.v" and $writememh() at "SRAM.v" appropriately.

**Thank you!**
